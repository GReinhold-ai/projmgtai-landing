// src/pages/api/extract-and-export.ts
// Wrapper endpoint for the landing page demo:
// 1. Receives PDF file upload
// 2. Extracts text (using pdf-parse or raw text)
// 3. Calls scope-extractor-v14 internally
// 4. Converts TOON rows to Excel
// 5. Returns .xlsx file

import type { NextApiRequest, NextApiResponse } from "next";
import { IncomingForm } from "formidable";
import fs from "fs";

// Disable body parsing — we handle multipart form data ourselves
export const config = {
  api: { bodyParser: false },
};

// Dynamically import pdf-parse (optional dependency)
async function extractTextFromPdf(filePath: string): Promise<string> {
  try {
    const pdfParse = (await import("pdf-parse")).default;
    const buffer = fs.readFileSync(filePath);
    const data = await pdfParse(buffer);
    return data.text || "";
  } catch {
    // Fallback: read as raw text (for text-based PDFs)
    return fs.readFileSync(filePath, "utf-8");
  }
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== "POST") {
    res.setHeader("Allow", "POST");
    return res.status(405).end("Method Not Allowed");
  }

  try {
    // Parse multipart form data
    const form = new IncomingForm({ maxFileSize: 50 * 1024 * 1024 }); // 50MB
    const { files } = await new Promise<{ files: any }>((resolve, reject) => {
      form.parse(req, (err: any, fields: any, files: any) => {
        if (err) reject(err);
        else resolve({ files });
      });
    });

    const uploadedFile = files.file?.[0] || files.file;
    if (!uploadedFile) {
      return res.status(400).json({ error: "No file uploaded" });
    }

    // Extract text from PDF
    const pdfText = await extractTextFromPdf(uploadedFile.filepath || uploadedFile.path);
    if (!pdfText || pdfText.trim().length < 10) {
      return res.status(400).json({ error: "Could not extract text from PDF. Try a text-based PDF." });
    }

    // Determine the base URL for internal API calls
    const protocol = req.headers["x-forwarded-proto"] || "https";
    const host = req.headers["x-forwarded-host"] || req.headers.host;
    const baseUrl = `${protocol}://${host}`;

    // Call scope-extractor-v14 internally
    const extractResponse = await fetch(`${baseUrl}/api/scope-extractor-v14`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        text: pdfText,
        projectId: uploadedFile.originalFilename || "uploaded-pdf",
        sheetRef: "uploaded",
      }),
    });

    const extractResult = await extractResponse.json();

    if (!extractResult.ok) {
      return res.status(400).json({
        error: extractResult.error || "Extraction failed",
        hints: extractResult.hints,
      });
    }

    // Build Excel from extraction results
    const ExcelJS = (await import("exceljs")).default;
    const workbook = new ExcelJS.Workbook();

    // ── Tab 1: Bid-Quote ──
    const bidSheet = workbook.addWorksheet("Bid-Quote");
    bidSheet.columns = [
      { header: "MILLWORK BID / QUOTE", width: 45 },
      { header: "", width: 25 },
      { header: "", width: 10 },
      { header: "", width: 10 },
      { header: "", width: 12 },
      { header: "", width: 12 },
      { header: "", width: 20 },
    ];
    bidSheet.addRow(["Generated by ProjMgtAI v14"]);
    bidSheet.addRow([]);
    bidSheet.addRow(["PROJECT INFORMATION"]);
    bidSheet.addRow(["Project Name:", extractResult.projectId || ""]);
    bidSheet.addRow(["Sheet:", extractResult.sheetRef || ""]);
    bidSheet.addRow(["Version:", "v14 (3-stage pipeline)"]);
    bidSheet.addRow(["Model:", extractResult.model || ""]);
    bidSheet.addRow([]);

    // Summary stats
    const stats = extractResult.stats || {};
    bidSheet.addRow(["EXTRACTION STATS"]);
    bidSheet.addRow(["Total Items:", stats.totalItems || 0]);
    bidSheet.addRow(["With Dimensions:", stats.withDimensions || 0]);
    bidSheet.addRow(["With Materials:", stats.withMaterials || 0]);
    bidSheet.addRow(["Hardware Items:", stats.withHardware || 0]);
    bidSheet.addRow(["Flagged Defaults:", stats.flaggedDefaults || 0]);
    bidSheet.addRow(["Duplicates Removed:", stats.duplicatesRemoved || 0]);
    bidSheet.addRow([]);

    // Assembly summaries
    if (extractResult.assemblies?.length > 0) {
      bidSheet.addRow(["ASSEMBLIES DETECTED"]);
      for (const assy of extractResult.assemblies) {
        bidSheet.addRow([
          `${assy.assemblyName} (${assy.assemblyId})`,
          `${assy.componentCount} components`,
          `${assy.cabinetCount} cabs`,
          `${assy.countertopCount} ctops`,
          `${assy.hardwareCount} hw`,
          `${assy.trimPartCount} trim`,
          assy.materialCodes?.join(", ") || "",
        ]);
      }
      bidSheet.addRow([]);
    }

    // Scope line items
    bidSheet.addRow(["#", "Description", "Qty", "Unit", "Type", "Material", "Notes"]);
    const rows = extractResult.rows || [];
    rows.forEach((row: any, i: number) => {
      bidSheet.addRow([
        i + 1,
        row.description || row.item_type || "",
        row.qty || 1,
        row.unit || "EA",
        row.item_type || "",
        row.material_code || row.material || "",
        row.notes || "",
      ]);
    });

    // ── Tab 2: Full Detail ──
    const detailSheet = workbook.addWorksheet("Full Detail");
    const detailHeaders = [
      "item_id", "assembly_id", "assembly_name", "section_id",
      "item_type", "description", "room", "qty", "unit",
      "length_mm", "width_mm", "height_mm", "depth_mm",
      "dim_source", "material", "material_code", "finish",
      "hardware_type", "hardware_spec",
      "sheet_ref", "detail_ref", "confidence", "notes",
    ];
    detailSheet.addRow(detailHeaders);
    detailSheet.columns = detailHeaders.map((h) => ({ header: h, width: 16 }));

    rows.forEach((row: any) => {
      detailSheet.addRow(
        detailHeaders.map((h) => row[h] ?? "")
      );
    });

    // ── Tab 3: Pre-Processor Hints ──
    const hintsSheet = workbook.addWorksheet("Pre-Processor Hints");
    const hints = extractResult.hints || {};

    hintsSheet.addRow(["DIMENSIONS EXTRACTED:", hints.dimensionCount || 0]);
    if (hints.dimensions?.length > 0) {
      hintsSheet.addRow(["Raw", "Inches", "MM", "Context", "Line"]);
      for (const d of hints.dimensions) {
        hintsSheet.addRow([d.raw, d.inches, d.mm, d.context, d.line]);
      }
    }
    hintsSheet.addRow([]);

    hintsSheet.addRow(["MATERIALS EXTRACTED:", hints.materialCount || 0]);
    if (hints.materials?.length > 0) {
      hintsSheet.addRow(["Code", "Full Name", "Category"]);
      for (const m of hints.materials) {
        hintsSheet.addRow([m.code, m.fullName, m.category]);
      }
    }
    hintsSheet.addRow([]);

    hintsSheet.addRow(["HARDWARE EXTRACTED:", hints.hardwareCount || 0]);
    if (hints.hardware?.length > 0) {
      hintsSheet.addRow(["Type", "Qty", "Size", "Spec"]);
      for (const h of hints.hardware) {
        hintsSheet.addRow([h.type, h.qty, h.size || "", h.spec || ""]);
      }
    }
    hintsSheet.addRow([]);

    hintsSheet.addRow(["EQUIPMENT TAGS:", hints.equipmentCount || 0]);
    if (hints.equipment?.length > 0) {
      hintsSheet.addRow(["Tag", "Description"]);
      for (const e of hints.equipment) {
        hintsSheet.addRow([e.tag, e.description || ""]);
      }
    }

    // ── Tab 4: Warnings ──
    const warnSheet = workbook.addWorksheet("Warnings");
    warnSheet.addRow(["POST-PROCESSOR WARNINGS"]);
    warnSheet.addRow([]);
    const warnings = extractResult.warnings || [];
    if (warnings.length === 0) {
      warnSheet.addRow(["No warnings — all items validated."]);
    } else {
      for (const w of warnings) {
        warnSheet.addRow([w]);
      }
    }

    // ── Tab 5: Timing ──
    const timingSheet = workbook.addWorksheet("Timing");
    const timing = extractResult.timing || {};
    timingSheet.addRow(["Pipeline Stage", "Duration (ms)"]);
    timingSheet.addRow(["Pre-processor (regex)", timing.preprocessMs || 0]);
    timingSheet.addRow(["LLM Extraction", timing.llmMs || 0]);
    timingSheet.addRow(["Post-processor", timing.postprocessMs || 0]);
    timingSheet.addRow(["Total", timing.totalMs || 0]);

    // Write to buffer and send
    const buffer = await workbook.xlsx.writeBuffer();

    // Set stats header for the frontend
    res.setHeader("X-Extract-Stats", JSON.stringify(stats));
    res.setHeader("Content-Type", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet");
    res.setHeader(
      "Content-Disposition",
      `attachment; filename="shop_order_v14.xlsx"`
    );

    return res.status(200).send(Buffer.from(buffer as ArrayBuffer));
  } catch (err: any) {
    console.error("[extract-and-export] error:", err);
    return res.status(500).json({ error: err.message || "Export failed" });
  }
}
